package com.bionym.app.passwordvault.controller;

import java.io.Serializable;
import java.util.Arrays;
import java.util.HashMap;

import android.annotation.SuppressLint;
import android.content.Context;
import android.util.Log;

import com.bionym.app.passwordvault.utils.Constants;
import com.bionym.app.passwordvault.utils.ScheduledTask;
import com.bionym.app.passwordvault.utils.SystemUtils;
import com.bionym.ncl.Ncl;
import com.bionym.ncl.NclCallback;
import com.bionym.ncl.NclEvent;
import com.bionym.ncl.NclEventAgreement;
import com.bionym.ncl.NclEventDisconnection;
import com.bionym.ncl.NclEventDiscovery;
import com.bionym.ncl.NclEventError;
import com.bionym.ncl.NclEventInit;
import com.bionym.ncl.NclEventProvision;
import com.bionym.ncl.NclProvision;

/**
 * ProvisionController is responsible for provisioning an Android device with a
 * Nymi Band. To listen on a provision process's progress, one should pass a
 * ProvisionProcessListener to the controller when calling
 * {@link #startProvisionProcess(ProvisionProcessListener)} method to start the
 * provision process.
 * <P>
 * ProvisionController will not initialize Ncl library, the Ncl library should
 * be initialized before invoking the controller. Neither will it disconnect a
 * connected connection.
 * <P>
 * This controller is designed to be reusable.''
 * 
 * @author sonal.agarwal
 * 
 * @Copyright (c) 2014 Nymi Inc. All rights reserved.
 * 
 */

public class ProvisionController implements Serializable {

	/**
	 * Autogenerated SerialVersionUID
	 */
	private static final long serialVersionUID = -3203787383719694702L;
	protected static final String LOG_TAG = ProvisionController.class.getName();
	protected static final int CLOSE_BLE_CONNECTION_DELAY_MILLIES = 1500; // time
																			// to
																			// wait
																			// after
																			// we
																			// close
																			// Nymi
																			// connection
																			// to
																			// close
																			// BLE
	protected static final int NCL_PROVISION_AGREEMENT_RETRIES = 3; // the
																	// number of
																	// times to
																	// retry
																	// upon
																	// failure
	protected static final int NCL_PROVISION_TIMEOUT_MILLIES = 60000; // time to
																		// wait
																		// for
																		// provision
	protected static final long NCL_DEFAULT_DISCOVERY_WAIT_TIME_MILLIES = 30000; // time
																					// to
																					// wait
																					// for
																					// discovery
	protected static final long INITIAL_DISCOVERY_WAIT_TIME_MILLIES = 1200; // The
																			// initial
																			// wait
																			// time
																			// for
																			// nymi
																			// discovery
	protected static final long DISCOVERY_WAIT_TIME_INCREMENT_MILLIES = 500; // The
																				// subsequent
																				// discovery
																				// wait
																				// time

	protected static ScheduledTask waitTask; // scheduled task for provision
												// timeout
	protected static ScheduledTask waitDiscovery; // scheduled task for waiting
													// the discovery process
	protected static NclCallback nclCallback;

	protected static int nymiHandle = Ncl.NYMI_HANDLE_ANY;

	protected static Context context;
	protected static boolean rejected;
	protected boolean destroying;
	protected static NclProvision provisionData;
	protected static State state;
	protected long discoveryWaitTime = NCL_DEFAULT_DISCOVERY_WAIT_TIME_MILLIES;
	protected static ProvisionProcessListener provisionListener;
	protected static Nymi nymi;
	protected static boolean[][] ledPatterns;
	protected static HashMap<Integer, Integer> deviceMap;

	/**
	 * Constructor
	 * 
	 * @param context
	 *            activity the activity showing the provision UI
	 */
	@SuppressLint("UseSparseArrays")
	public ProvisionController(Context context) {
		ProvisionController.context = context;

		deviceMap = new HashMap<Integer, Integer>();
		rejected = false;
		destroying = false;
	}

	/**
	 * 
	 * @return the connected Nymi handle
	 */
	public int getNymiHandle() {
		return nymiHandle;
	}

	/**
	 * Called to stop the process, but leave NCL connection around
	 */
	public static void stopProvision() {
		cancelWaitTask();
		if (nymi != null && nclCallback != null) {
			nymi.removeCallback(nclCallback);
			nclCallback = null;
		}

		if (isProvisioning()) {
			state = State.FAILED;
		}
		nymiHandle = Ncl.NYMI_HANDLE_ANY;
	}

	/**
	 * 
	 * @return the current progress listener
	 */
	public ProvisionProcessListener getProvisionListener() {
		return provisionListener;
	}

	/**
	 * Set the progress listener
	 * 
	 * @param provisionListener
	 *            the listener
	 */
	public void setProvisionListener(ProvisionProcessListener provisionListener) {
		ProvisionController.provisionListener = provisionListener;
	}

	/**
	 * 
	 * @return the agreement LED pattern
	 */
	public boolean[] getLedPatterns() {
		return ledPatterns != null ? ledPatterns[0] : null;
	}

	/**
	 * Start the provision process
	 * 
	 * @param listener
	 *            the process listener
	 * @return true of the provision process is started
	 */
	public boolean startProvisionProcess(ProvisionProcessListener listener) {
		return startProvisionProcess(listener, NCL_DEFAULT_DISCOVERY_WAIT_TIME_MILLIES);
	}

	/**
	 * Start the provision process
	 * 
	 * @param listener
	 *            the process listener
	 * @param discoveryWaitTime
	 *            time to wait for device discovery
	 * @return true of the provision process is started
	 */
	public boolean startProvisionProcess(ProvisionProcessListener listener, long discoveryWaitTime) {
		if (isProvisioning()) {
			stopProvision();
		}

		this.discoveryWaitTime = discoveryWaitTime;
		provisionListener = listener;

		if (Constants.ISDEVICE) {
			nymi = NymiBand.getInstance();
		} else {
			nymi = Nymulator.getInstance();
		}
		if (nymi == null) { // failed to initialize NCL
			Log.d(LOG_TAG, "BLE failed to initialize!");
			return false;
		}

		if (nclCallback == null) {
			nclCallback = createNclCallback();
		}

		nymi.addCallback(nclCallback);
		// initialize device map
		deviceMap.clear();
		SystemUtils.runTask(new Runnable() { // make sure we are not running on
												// the UI thread
					@Override
					public void run() {
						doDiscovery();
					}
				});

		return true;
	}

	/**
	 * Return a new instanceof NclCallback
	 */
	protected NclCallback createNclCallback() {
		return new MyNclCallback();
	}

	/**
	 * 
	 * @return true if provisioning is in progress
	 */
	public static boolean isProvisioning() {
		return state != null && (state == State.DISCOVERING || state == State.AGREEING || state == State.PROVISIONING || state == State.AGREED);
	}

	/**
	 * Call this method to agree on the agreement pattern received from Nymi
	 * 
	 * @param strong
	 *            true for strong provisioning
	 * @return true if the operation is successful
	 */
	public boolean acceptAgreement(final boolean strong) {
		Log.d("accept", "Beginning");
		if (state != State.AGREED) {
			return false;
		}

		rejected = false;
		state = State.PROVISIONING;
		SystemUtils.runTask(new Runnable() {
			@Override
			public void run() {
				nymi.provision(nymiHandle, strong);
			}
		});
		return true;
	}

	/**
	 * Call this method to reject the current agreement pattern
	 * 
	 * @return true if the operation is successful
	 */
	public boolean rejectAgreement() {
		Log.d(LOG_TAG, "Reject pattern" + state);
		if (state != State.AGREED) {
			return false;
		}

		deviceMap.remove(nymiHandle);
		rejected = true;
		state = State.AGREEING;

		SystemUtils.runTask(new Runnable() {
			@Override
			public void run() {
				nymi.disconnect(nymiHandle);
			}
		});
		return true;
	}

	/**
	 * 
	 * @return the current provision process state
	 */
	public State getState() {
		return state;
	}

	/**
	 * 
	 * @return the provision that was made
	 */
	public NclProvision getProvision() {
		return provisionData;
	}

	protected boolean doDiscovery() {
		if (provisionListener != null) {
			provisionListener.onStartProcess(ProvisionController.this);
		}

		int bleStatus = nymi.enableBle();
		if (bleStatus == Nymi.BLE_STATUS_OK) {
			if (nymi.startDiscovery() == false) {
				state = State.FAILED;
				Log.d(LOG_TAG, "Start discovery failed");
				if (provisionListener != null) {
					provisionListener.onFailure(ProvisionController.this);
				}

				stopProvision();
				return false;
			}

			state = State.DISCOVERING;
			waitTask = SystemUtils.runTaskAfterMillies(new Runnable() {
				@Override
				public void run() { // timeout when we get here
					if (waitTask != null && waitTask.getRunnable() == this) {
						if (state == State.DISCOVERING || state == State.AGREEING || state == State.AGREED || state == State.PROVISIONING) { // timeout
							state = State.NO_DEVICE;
							Log.d(LOG_TAG, "Timeout provisioning nymi");
							if (provisionListener != null) {
								provisionListener.onFailure(ProvisionController.this);
							}

							stopProvision();
						}

						waitTask = null;
					}
				}
			}, NCL_PROVISION_TIMEOUT_MILLIES);

			// now wait for the device discovering to complete
			Log.d(LOG_TAG, "Started discovery, wait for discovery ...");

			final long startTime = System.currentTimeMillis();
			waitDiscovery = SystemUtils.runTaskAfterMillies(new Runnable() {
				@Override
				public void run() {
					if (waitDiscovery != null && waitDiscovery.getRunnable() == this) {
						Log.d(LOG_TAG, "end waiting");
						long remains = discoveryWaitTime + startTime - System.currentTimeMillis();
						if (remains <= 0 || deviceMap.size() > 0) {
							if (nymi.stopScan() == false) {
								state = State.FAILED;
								if (provisionListener != null) {
									provisionListener.onFailure(ProvisionController.this);
								}

								stopProvision();
								Log.d(LOG_TAG, "stopFailed");
							}

							if (deviceMap.isEmpty()) {
								state = State.NO_DEVICE;
								Log.d(LOG_TAG, "No Nymi");
								if (provisionListener != null) {
									provisionListener.onFailure(ProvisionController.this);
								}
								stopProvision();
							} else {
								Log.d(LOG_TAG, "Establish agreement");
								int closestHandle = findClosestHandle();
								nymiHandle = closestHandle;
								if (nymi.agree(closestHandle)) {
									state = State.AGREEING;
								} else {
									Log.d(LOG_TAG, "Failed to agree");
									state = State.FAILED;
									if (provisionListener != null) {
										provisionListener.onFailure(ProvisionController.this);
									}
									stopProvision();
								}
							}
						} else {
							waitDiscovery = SystemUtils.runTaskAfterMillies(this, Math.min(DISCOVERY_WAIT_TIME_INCREMENT_MILLIES, remains));
						}
					}
				}
			}, INITIAL_DISCOVERY_WAIT_TIME_MILLIES);

			return true;
		}

		// BLE failed
		Log.d(LOG_TAG, "Start discovery nor proceeded, BLE status not ready: " + bleStatus);
		state = (bleStatus == Nymi.BLE_STATUS_DISABLED_AIRPLANE_MODE) ? State.AIRPLANE_MODE : (bleStatus == Nymi.BLE_STATUS_DISABLED ? State.BLE_DISABLED
				: State.NO_DEVICE);
		if (provisionListener != null) {
			provisionListener.onFailure(this);
		}
		stopProvision();
		return false;
	}

	/**
	 * Cancel wait task
	 * 
	 * @return true if the task is cancelled, false if the waitTask had been
	 *         cancelled already
	 */
	protected static boolean cancelWaitTask() {
		if (waitTask != null) { // we are still waiting
			waitTask.cancel(false);
			waitTask = null;
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Process discovered devices, and establish agreement with the closest one
	 * 
	 * @return true if this operation is successful
	 */
	protected boolean establishAgreement() {
		if (deviceMap.isEmpty()) {
			state = State.NO_DEVICE;
			Log.d(LOG_TAG, "No Nymi");
			if (provisionListener != null) {
				provisionListener.onFailure(this);
			}

			stopProvision();
			return false;
		}

		int closestHandle = findClosestHandle();
		nymiHandle = closestHandle;
		state = State.AGREEING;

		Log.d(LOG_TAG, "Send agreement ...");
		return (nymi.agree(closestHandle) == false);
	}

	/**
	 * 
	 * @return the closest Nymi's handle
	 */
	int findClosestHandle() {
		int closestRssi = 0;
		int closestHandle = -1;
		for (HashMap.Entry<Integer, Integer> entry : deviceMap.entrySet()) {
			int handle = entry.getKey();
			int rssi = entry.getValue();
			if (closestHandle == -1 || rssi > closestRssi) {
				closestHandle = handle;
				closestRssi = rssi;
			}
		}
		return closestHandle;
	}

	protected static class MyNclCallback implements NclCallback {
		public void call(NclEvent event, Object userData) {
			Log.d(LOG_TAG, this.toString() + ": " + event.getClass().getName());
			if (event instanceof NclEventInit) {
				if (((NclEventInit) event).success) {
					Log.d(LOG_TAG, "Init Success");
				} else {
					Log.d(LOG_TAG, "Init Failed");
				}
			} else if (event instanceof NclEventDiscovery) {
				Log.d(LOG_TAG, "Device discovered");
				if (waitTask != null) { // device discovered, not yet timeout
					if (deviceMap.containsKey(((NclEventDiscovery) event).nymiHandle)) {
						int rssi = deviceMap.get(((NclEventDiscovery) event).nymiHandle);
						deviceMap.put(((NclEventDiscovery) event).nymiHandle, (((NclEventDiscovery) event).rssi + rssi) >> 1); // put
																																// the
																																// average,
																																// give
																																// the
																																// current
																																// one
																																// more
																																// weight
					} else {
						deviceMap.put(((NclEventDiscovery) event).nymiHandle, ((NclEventDiscovery) event).rssi);
					}
				}
			} else if (event instanceof NclEventAgreement) {
				if (((NclEventAgreement) event).nymiHandle == nymiHandle) {
					if (waitTask != null) { // received agreement pattern, not
											// yet timeout
						Log.d(LOG_TAG, "Received agreement pattern!");
						state = State.AGREED;
						nymiHandle = ((NclEventAgreement) event).nymiHandle;
						ledPatterns = ((NclEventAgreement) event).leds;
						rejected = false;
						if (provisionListener != null) {
							provisionListener.onAgreement(new ProvisionController(context));
						}
						Log.d(LOG_TAG, "Agreement pattern: " + Arrays.toString(ledPatterns[0]));
					}
				}
			} else if (event instanceof NclEventProvision) {
				if (((NclEventProvision) event).nymiHandle == nymiHandle) {
					Log.d(LOG_TAG, "Provision is successful!");
					if (cancelWaitTask()) { // provision completed, not yet
											// timeout
						state = State.SUCCEEDED;
						provisionData = ((NclEventProvision) event).provision;
						Log.d(LOG_TAG,
								"Nymi provisioned:\n\tID: " + SystemUtils.toHexString(provisionData.id.v) + "\n\tKey: "
										+ SystemUtils.toHexString(provisionData.key.v));
					}
				}
			} else if (event instanceof NclEventDisconnection) {
				if (((NclEventDisconnection) event).nymiHandle == nymiHandle) {
					cancelWaitTask();
					nymiHandle = Ncl.NYMI_HANDLE_ANY;
					if (state == State.SUCCEEDED) {
						if (provisionListener != null) {
							provisionListener.onProvisioned(new ProvisionController(context));
						}
						SystemUtils.runTaskAfterMillies(new Runnable() {
							@Override
							public void run() {
								if (provisionListener != null) {
									provisionListener.onDisconnected(new ProvisionController(context));
								}
							}
						}, 100);
					} else if (state != null) {
						if (state == State.AGREEING) {
							Log.d(LOG_TAG, "Disconnect during agreement");
						} else if (state == State.PROVISIONING) {
							Log.d(LOG_TAG, "Disconnected after provisioned");
						} else {
							Log.d(LOG_TAG, "Disconnected, failed!");
						}

						if (provisionListener != null) {
							provisionListener.onFailure(new ProvisionController(context));
						}
						state = State.FAILED;
					}
					stopProvision();
				}
			} else if (event instanceof NclEventError) {
				Log.e(LOG_TAG, "NCL failed!");
				cancelWaitTask();
				if (state != null && state != State.SUCCEEDED) {
					state = State.FAILED;
					if (provisionListener != null) {
						provisionListener.onFailure(new ProvisionController(context));
					}

					stopProvision();
				}
			}
		}
	}

	/**
	 * Interface for listening on the provision process
	 * 
	 */
	public interface ProvisionProcessListener {
		/**
		 * Called when the provision process is started
		 * 
		 * @param controller
		 *            the ProvisionController performing the provision
		 */
		public void onStartProcess(ProvisionController controller);

		/**
		 * Called when the agreement pattern is available
		 * 
		 * @param controller
		 *            the ProvisionController performing the provision
		 */
		public void onAgreement(ProvisionController controller);

		/**
		 * Called when the provision process is completed
		 * 
		 * @param controller
		 *            the ProvisionController performing the provision
		 */
		public void onProvisioned(ProvisionController controller);

		/**
		 * Called when the provision process failed
		 * 
		 * @param controller
		 *            the ProvisionController performing the provision
		 */
		public void onFailure(ProvisionController controller);

		/**
		 * Called when the connected Nymi during the provision process is
		 * disconnected
		 * 
		 * @param controller
		 *            the ProvisionController performing the provision
		 */
		public void onDisconnected(ProvisionController controller);
	}

	public enum State {
		/**
		 * In discovering process
		 */
		DISCOVERING,

		/**
		 * In agreement process
		 */
		AGREEING,

		/**
		 * A Nymi is agreed
		 */
		AGREED,

		/**
		 * The agreed Nymi is in provisioning
		 */
		PROVISIONING,

		/**
		 * The provisioning is completed
		 */
		SUCCEEDED,

		/**
		 * There is no Nymi Band
		 */
		NO_DEVICE,

		/**
		 * The validation failed
		 */
		FAILED,

		/**
		 * The device has no BLE
		 */
		NO_BLE,

		/**
		 * The device's BLE is disabled
		 */
		BLE_DISABLED,

		/**
		 * The device's BLE is disabled as it is in airplane mode
		 */
		AIRPLANE_MODE
	}
}
